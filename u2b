#!/usr/bin/perl
use JSON::XS;
use YAML;
use URI::Escape;
# Copyright: SZABO Gergely <szg@subogero.com>, GNU GPL v2
sub search; sub extract_streams;
sub print_html; sub print_json; sub print_yaml; sub print_ini;
sub help {
    print <<EOF;
Usage:
u2b -h
u2b -u url
u2b [ -f <format> ] [words]

Search YouTube for words, print title, stream URL and thumbnail link of hits.
When words are omitted, a list of featured videos is printed.
With -u option extract stream URL playable by the Raspberry Pi's omxplayer.

-h          Print this help text and exit
-e          Extract 1st stream URL of 1st search hit
-u url      Print omxplayer-playable stream link for video URL
-f <format> Supported formats are ini (default), json, yaml and html

In html format, each video has a stream link called its title, followed
by a thumbnail image.
EOF
    exit shift;
}

help 0 if $ARGV[0] eq '-h';

# Extract stream URL
if ($ARGV[0] eq '-u') {
    shift;
    my $url = shift;
    print `youtube-dl -g $url`;
    exit 0;
}

# Format
if ($ARGV[0] eq '-f') {
    shift;
    $format = shift;
}

my @hits = search;

if ($ARGV[0] eq '-e') {
    my @streams = extract_streams $hits[0]->{name};
    my $url = $streams[0]->{url};
    print $url;
    system "curl -c jar -L '$url' >>fifo &";
    system "omxplayer -ohdmi fifo";
} elsif ($format eq 'html') {
    print_html @hits;
} elsif ($format eq 'json') {
    print_json @hits;
} elsif ($format eq 'yaml') {
    print_yaml @hits;
} else {
    print_ini @hits;
}

# Query, URL-encoded
sub search {
    $query = 'https://gdata.youtube.com/feeds/api/videos?q=';
    $query .= join '%20', @ARGV;
    $xml = `curl $query 2>/dev/null`;
    # Parse response XML
    my @hits;
    while ($xml =~ m|^.*?<entry>(.+?)</media:group>(.*)|s) {
        $xml = $2;
        my $vid = $1;
        next unless $vid =~ m|<link .+?href='([^']+?)&amp;|;
        my $url = $1;
        $vid =~ m|<media:title type='plain'>(.+?)</media:title>|;
        my $title = $1;
        $vid =~ m|<media:thumbnail url='([^']+?)' height='90'[^>]+?/>|;
        my $thumbnail = $1;
        push @hits, { thumbnail => $thumbnail, label => $title, name => $url };
    }
    return @hits;
}

# Extract stream URLs and metadata from a video HTML page:
# Look for quoted string after "url_encoded_fmt_stream_map":
# uri_unescape string
# Comma-split for list of stream data (comma inside quote does not split)
# Split each part by "\u0026" for url, itag, type, quality, fallback_host keys
# Return list of parts, each a hashref of url, itag, type, quality
sub extract_streams {
    unlink 'jar';
    my $html = `curl -c jar -L $_[0] 2>/dev/null`;
    return unless $html =~ /url_encoded_fmt_stream_map":"(.+?)"/;
    my $map = uri_unescape $1;
    my ($stream, @streams);
    while ($map) {
        $stream .= $1 if $map =~ s/^([^,"]+)//;
        $stream .= $1 if $map =~ s/^("[^"]+?")//;
        if ($map eq '' || $map =~ s/^,//) {
            push @streams, $stream;
            $stream = '';
        }
    }
    my @result;
    foreach my $str (@streams) {
        my %fields = map { split /=/, $_, 2 } split /\\u0026/, $str;
        push @result, \%fields;
    }
    return @result;
}

# Pretty printers
sub print_html {
    foreach (@_) {
        print <<EOF;
<p>
<a href="$_->{name}">$_->{label}</a>
<br>
<img src="$_->{thumbnail}"/>
</p>
EOF
    }
}

sub print_json {
    print encode_json \@_;
}

sub print_yaml {
    print Dump \@_;
}

sub print_ini {
    $i = 0;
    foreach (@_) {
        print <<EOF;
[$i]
label=$_->{label}
name=$_->{name}
thumbnail=$_->{thumbnail}
EOF
        $i++;
    }
}
