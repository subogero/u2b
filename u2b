#!/usr/bin/perl
use strict;
use warnings;
use JSON::XS;
use YAML;
use URI::Escape;
# Copyright: SZABO Gergely <szg@subogero.com>, GNU GPL v2
sub search; sub extract_streams;
sub print_html; sub print_json; sub print_yaml; sub print_ini; sub suffix;
sub help {
    print <<EOF;
Usage:
u2b [options] [command] term

u2b uWQU4hSFyhU   # Print page URL, thumbnail URL and title of video id
u2b u uWQU4hSFyhU # Print URL of stream for video id
u2b d uWQU4hSFyhU # Download video id
u2b m uWQU4hSFyhU # Play video id via mplayer
u2b s Foo         # Print info about search hits for Foo
u2b 0s Foo        # Print info about 1st search hit for Foo
u2b u0s Foo       # Print URL of stream for 1st search hit for Foo
u2b d1s Foo       # Download 2nd search hit for Foo
u2b m12s Foo      # Play 13th search hit for Foo

Fast YouTube search, download, play and stream-URL extractor utility.
Playback is pluggable via config file .u2b.yml.

The command has 3 optional parts:
- one letter verb, just print info if omitted
- number for selection from search hits, when using a search
- s for search

The term is either a YouTube video link, a video id, or a search term,
the rest of the arguments is considered part of the search term.

Verbs:
u: extract directly playable stream URL
d: download video, name it after 11-letter id
l: play video via omxplayer -olocal
h: play video via omxplayer -ohdmi
I: play video via omxd I (default omxd audio output)
J: play video via omxd I (jack)
H: play video via omxd I (HDMI)
m: play video via mplayer
All upper/lowercase letters except u, d can be mapped to different players
via config file .u2b.yml.

Options:
-f <format>  Choose print format from yaml (default), json, ini, html
EOF
    exit shift;
}

help 0 if $ARGV[0] eq '-h';

# Format
my $format = 'yaml';
if ($ARGV[0] eq '-f') {
    shift;
    $format = shift;
}

# Verb, video, search terms
my ($verb, $video, $index, $search);
if (@ARGV == 1) {
    $video = shift;
} else {
    my $cmd = shift;
    if ($cmd =~ /^([A-Za-z])?((\d+)?s)$/) {
        ($verb, $search, $index) = ($1, $2, $3);
    } else {
        $verb = $cmd;
    }
    $video = shift unless $search;
}
if ($video) {
    $video =~ s/^.*(.{11})$/$1/; # Just leave id
    $search = '0s';
    $index = 0;
}
#print "vid: $video, verb: $verb, search: $search, index: $index\n";

# Search
my @hits = search $video || @ARGV;
die "Not enough search hits for $index\n" if defined $index && $index >= @hits;
@hits = ($hits[$index]) if !$verb && defined $index;

# Do verb or display data
my %player_map = (
    l => 'omxplayer -olocal',
    h => 'omxplayer -ohdmi',
    I => 'omxd I',
    J => 'omxd J',
    H => 'omxd H',
    m => 'mplayer -fs',
);
if ($verb) {
    $index = 0 unless defined $index;
    my $txt = $hits[$index]->{label};
    my $pic = $hits[$index]->{thumbnail};
    my $vid = $hits[$index]->{name};
    my @streams = extract_streams $vid;
    $vid =~ s/^.*(.{11})$/$1/; # Just leave id
    my $url = $streams[0]->{url};
    if ($verb eq 'u') {
        print $url;
    } elsif ($verb eq 'd') {
        my $ext = $streams[0]->{extension};
        system "curl -c jar -L '$url' >$vid.$ext";
        (my $th_ext = $pic) =~ s/^.+\.//;
        system "curl -c jar -L '$pic' >$vid.$th_ext";
        if (open TXT, ">$vid.txt") {
            print TXT "$txt\n";
            close TXT;
        }
    } elsif ($player_map{$verb}) {
        -e 'fifo' and unlink 'fifo';
        system "mkfifo fifo";
        system "curl -c jar -L '$url' >>fifo 2>/dev/null &";
        system "$player_map{$verb} fifo";
    } else {
        die "Verb $verb not mapped to any player";
    }
} elsif ($format eq 'html') {
    print_html @hits;
} elsif ($format eq 'json') {
    print_json @hits;
} elsif ($format eq 'yaml') {
    print_yaml @hits;
} elsif ($format eq 'ini') {
    print_ini @hits;
} else {
    help 1;
}

# Query, URL-encoded
sub search {
    my $query = 'https://gdata.youtube.com/feeds/api/videos?q=';
    $query .= join '%20', @_;
    my $xml = `curl $query 2>/dev/null`;
    # Parse response XML
    my @hits;
    while ($xml =~ m|^.*?<entry>(.+?)</media:group>(.*)|s) {
        $xml = $2;
        my $vid = $1;
        next unless $vid =~ m|<link .+?href='([^']+?)&amp;|;
        my $url = $1;
        $vid =~ m|<media:title type='plain'>(.+?)</media:title>|;
        my $title = $1;
        $vid =~ m|<media:thumbnail url='([^']+?)' height='90'[^>]+?/>|;
        my $thumbnail = $1;
        push @hits, { thumbnail => $thumbnail, label => $title, name => $url };
    }
    return @hits;
}

# Extract stream URLs and metadata from a video HTML page:
# Look for quoted string after "url_encoded_fmt_stream_map":
# uri_unescape string
# Comma-split for list of stream data (comma inside quote does not split)
# Split each part by "\u0026" for url, itag, type, quality, fallback_host keys
# Return list of parts, each a hashref of url, itag, type, quality
sub extract_streams {
    unlink 'jar';
    my $html = `curl -c jar -L $_[0] 2>/dev/null`;
    return unless $html =~ /url_encoded_fmt_stream_map":"(.+?)"/;
    my $map = uri_unescape $1;
    my ($stream, @streams);
    while ($map) {
        $stream .= $1 if $map =~ s/^([^,"]+)//;
        $stream .= $1 if $map =~ s/^("[^"]+?")//;
        if ($map eq '' || $map =~ s/^,//) {
            push @streams, $stream;
            $stream = '';
        }
    }
    my @result;
    foreach my $str (@streams) {
        my %fields = map { split /=/, $_, 2 } split /\\u0026/, $str;
        $fields{extension} = suffix $fields{itag};
        push @result, \%fields;
    }
    return @result;
}

# Map itag format ids to file extensions
sub suffix {
    my $itag = shift;
    return $itag =~ /^(43|44|45|46)$/ ? 'webm'
         : $itag =~ /^(18|22|37|38)$/ ? 'mp4'
         : $itag =~ /^(13|17|36)$/    ? '3gp'
         :                              'flv';
}

# Pretty printers
sub print_html {
    foreach (@_) {
        print <<EOF;
<p>
<a href="$_->{name}">$_->{label}</a>
<br>
<img src="$_->{thumbnail}"/>
</p>
EOF
    }
}

sub print_json {
    print encode_json \@_;
}

sub print_yaml {
    print Dump \@_;
}

sub print_ini {
    my $i = 0;
    foreach (@_) {
        print <<EOF;
[$i]
label=$_->{label}
name=$_->{name}
thumbnail=$_->{thumbnail}
EOF
        $i++;
    }
}
